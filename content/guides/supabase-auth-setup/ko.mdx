---
title: "Supabase 인증 설정 가이드 - 이메일/OAuth 연동"
description: "Supabase에서 이메일 인증, OAuth(Google, GitHub), 매직 링크를 설정하고 Next.js 앱에 통합하는 방법을 배웁니다."
---

# Supabase 인증 설정 가이드

Supabase Auth는 완전한 사용자 인증 시스템을 제공하며, 이메일/비밀번호, OAuth, 매직 링크, 전화번호 인증 등 다양한 인증 방식을 지원합니다. 이 가이드에서는 주요 인증 방식을 설정하고 Next.js 앱에 통합하는 방법을 알아봅니다.

<FreeTierInfo
  limit="Unlimited users"
  period="month"
  status="available"
/>

## 시작하기 전에

다음 항목들이 준비되어 있는지 확인하세요.

- [Supabase 계정 및 프로젝트 생성](../supabase-account-setup) 완료
- [Supabase 데이터베이스 설정](../supabase-database-setup) 완료
- Next.js 프로젝트 (또는 다른 프론트엔드 프레임워크)
- Google/GitHub 계정 (OAuth 설정 시)

<Callout type="info">
Supabase Auth는 JWT(JSON Web Token) 기반이며, Row Level Security와 완벽하게 통합됩니다. 별도의 백엔드 서버 없이도 안전한 인증 시스템을 구현할 수 있습니다.
</Callout>

<Step number={1} title="인증 제공자(Providers) 활성화하기">

Supabase 대시보드에서 사용할 인증 방식을 활성화합니다.

1. Supabase 대시보드에서 **Authentication**을 클릭합니다
2. **Providers** 탭을 선택합니다
3. 활성화할 인증 방식을 확인합니다

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step1-providers-ko.png"
  alt="인증 제공자 목록"
  caption="Supabase에서 지원하는 다양한 인증 제공자"
/>

### 기본 활성화된 제공자

- **Email**: 이메일/비밀번호 인증 (기본 활성화)
- **Phone**: 전화번호 인증 (SMS)

### 추가 가능한 OAuth 제공자

- Google
- GitHub
- GitLab
- Discord
- Facebook
- Apple
- Twitter
- Microsoft
- 기타 20+ 제공자

<DevTip title="인증 제공자 선택 가이드">
**이메일/비밀번호:**
- 가장 기본적인 인증 방식
- 별도의 설정 없이 바로 사용 가능
- 비밀번호 재설정, 이메일 확인 기능 포함

**매직 링크 (Passwordless):**
- 비밀번호 없이 이메일로만 로그인
- 사용자 경험 향상, 보안성 우수
- 이메일 인증이 자동으로 완료됨

**OAuth (소셜 로그인):**
- 사용자가 이미 가지고 있는 계정으로 로그인
- 회원가입 마찰 감소
- 이메일 주소 자동 수집
- 각 제공자별 API 키 설정 필요

**전화번호 인증:**
- SMS로 인증 코드 발송
- 추가 비용 발생 (Twilio 등)
- 특정 국가/지역에 적합
</DevTip>

<Checkpoint>
- [ ] Authentication 메뉴 접근 완료
- [ ] Providers 탭 확인 완료
- [ ] Email 제공자 활성화 확인
</Checkpoint>

</Step>

<Step number={2} title="이메일 인증 설정하기">

이메일/비밀번호 인증과 매직 링크를 설정합니다.

### 이메일 인증 설정

1. **Providers** 탭에서 **Email**을 클릭합니다
2. 다음 옵션을 설정합니다:

   **Enable Email provider**: 활성화 (기본값)

   **Confirm email**: 활성화 (권장)
   - 활성화 시: 회원가입 후 이메일 확인 필요
   - 비활성화 시: 즉시 로그인 가능 (테스트용)

   **Enable Email Signup**: 활성화
   - 비활성화하면 새 사용자 가입 불가 (초대 전용 앱)

   **Enable Magic Link**: 활성화 (선택사항)
   - 비밀번호 없이 이메일 링크로만 로그인

3. **Save** 버튼을 클릭합니다

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step2-email-settings-ko.png"
  alt="이메일 인증 설정"
  caption="이메일 인증 옵션을 설정합니다"
/>

### 이메일 템플릿 커스터마이징

1. **Email Templates** 탭을 클릭합니다
2. 다음 이메일 템플릿을 수정할 수 있습니다:
   - **Confirm signup**: 회원가입 확인 이메일
   - **Magic Link**: 매직 링크 이메일
   - **Change Email Address**: 이메일 주소 변경 확인
   - **Reset Password**: 비밀번호 재설정

<CopyBlock language="html">
{`<!-- 회원가입 확인 이메일 예시 -->
<h2>회원가입을 환영합니다!</h2>
<p>아래 버튼을 클릭하여 이메일 주소를 확인해주세요.</p>
<a href="{{ .ConfirmationURL }}">이메일 확인하기</a>
<p>또는 다음 링크를 복사하여 브라우저에 붙여넣으세요:</p>
<p>{{ .ConfirmationURL }}</p>`}
</CopyBlock>

<DevTip title="이메일 템플릿 변수">
**사용 가능한 변수:**
- `{{ .ConfirmationURL }}`: 확인 링크
- `{{ .Token }}`: 인증 토큰
- `{{ .TokenHash }}`: 토큰 해시
- `{{ .SiteURL }}`: 사이트 URL
- `{{ .Email }}`: 사용자 이메일

**HTML 이메일 작성 팁:**
- 인라인 CSS 사용 (외부 스타일시트 지원 안 됨)
- 테이블 기반 레이아웃 사용 (이메일 클라이언트 호환성)
- 다크 모드 고려
- 모바일 반응형 디자인
</DevTip>

<Checkpoint>
- [ ] Email provider 설정 완료
- [ ] Confirm email 옵션 설정
- [ ] 이메일 템플릿 확인 완료
</Checkpoint>

</Step>

<Step number={3} title="OAuth 제공자 설정하기 (Google, GitHub)">

Google과 GitHub OAuth를 설정하여 소셜 로그인을 활성화합니다.

### Google OAuth 설정

#### 1. Google Cloud Console에서 OAuth 클라이언트 생성

1. [Google Cloud Console](https://console.cloud.google.com/)에 접속합니다
2. 새 프로젝트를 생성하거나 기존 프로젝트를 선택합니다
3. **APIs & Services** > **Credentials**로 이동합니다
4. **Create Credentials** > **OAuth client ID**를 클릭합니다
5. **Application type**: Web application 선택
6. **Name**: 앱 이름 입력 (예: My App - Supabase)
7. **Authorized JavaScript origins**에 추가:
   ```
   https://your-project-ref.supabase.co
   ```
8. **Authorized redirect URIs**에 추가:
   ```
   https://your-project-ref.supabase.co/auth/v1/callback
   ```
9. **Create** 클릭
10. **Client ID**와 **Client Secret**을 복사합니다

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step3-google-oauth-ko.png"
  alt="Google OAuth 클라이언트 생성"
  caption="Google Cloud Console에서 OAuth 클라이언트를 생성합니다"
/>

#### 2. Supabase에 Google OAuth 설정

1. Supabase 대시보드의 **Authentication** > **Providers**로 돌아갑니다
2. **Google**을 클릭합니다
3. **Enable Google provider** 활성화
4. 복사한 **Client ID**와 **Client Secret**을 입력합니다
5. **Save** 클릭

### GitHub OAuth 설정

#### 1. GitHub에서 OAuth App 생성

1. [GitHub Settings](https://github.com/settings/developers)에 접속합니다
2. **OAuth Apps** > **New OAuth App**을 클릭합니다
3. 앱 정보를 입력합니다:
   - **Application name**: 앱 이름 (예: My App)
   - **Homepage URL**: `https://your-domain.com`
   - **Authorization callback URL**:
     ```
     https://your-project-ref.supabase.co/auth/v1/callback
     ```
4. **Register application** 클릭
5. **Client ID**를 확인하고, **Generate a new client secret**을 클릭합니다
6. **Client Secret**을 복사합니다 (한 번만 표시됨)

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step3-github-oauth-ko.png"
  alt="GitHub OAuth App 생성"
  caption="GitHub에서 OAuth App을 생성합니다"
/>

#### 2. Supabase에 GitHub OAuth 설정

1. Supabase 대시보드의 **Authentication** > **Providers**로 돌아갑니다
2. **GitHub**을 클릭합니다
3. **Enable GitHub provider** 활성화
4. **Client ID**와 **Client Secret**을 입력합니다
5. **Save** 클릭

<DevTip title="OAuth Redirect URL 찾기">
**Supabase 프로젝트의 Redirect URL:**
```
https://<project-ref>.supabase.co/auth/v1/callback
```

**Project Ref 확인 방법:**
1. Supabase 대시보드 > Project Settings > General
2. "Reference ID" 또는 Project URL에서 확인
3. 예: `https://abcdefghijklmnop.supabase.co`에서 `abcdefghijklmnop`가 project-ref

**로컬 개발 시:**
- OAuth는 프로덕션 URL로만 작동
- 로컬 개발에서 테스트하려면 ngrok 등을 사용하여 터널링 필요
- 또는 Supabase CLI의 로컬 개발 환경 사용
</DevTip>

<Callout type="warning">
**Client Secret 보안 주의사항:**
- Client Secret은 절대 클라이언트 코드에 포함하지 마세요
- GitHub 등에 커밋하지 마세요
- Supabase 대시보드에만 입력하면 됩니다 (서버에서 처리)
</Callout>

<Checkpoint>
- [ ] Google OAuth 클라이언트 생성 완료
- [ ] Supabase에 Google OAuth 설정 완료
- [ ] GitHub OAuth App 생성 완료
- [ ] Supabase에 GitHub OAuth 설정 완료
</Checkpoint>

</Step>

<Step number={4} title="Site URL 및 Redirect URLs 설정하기">

인증 후 리디렉션될 URL을 설정합니다.

1. **Authentication** > **URL Configuration**으로 이동합니다
2. 다음 URL들을 설정합니다:

### Site URL

앱의 메인 URL을 입력합니다.

- **개발 환경**: `http://localhost:3000`
- **프로덕션**: `https://your-domain.com`

### Redirect URLs

인증 후 허용할 리디렉션 URL 목록을 입력합니다 (한 줄에 하나씩).

<CopyBlock language="text">
{`http://localhost:3000/**
https://your-domain.com/**
https://www.your-domain.com/**`}
</CopyBlock>

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step4-url-config-ko.png"
  alt="URL 설정"
  caption="Site URL과 Redirect URLs를 설정합니다"
/>

<DevTip title="Redirect URL 와일드카드 패턴">
**사용 가능한 패턴:**
- `*`: 한 경로 세그먼트 매칭
- `**`: 모든 경로 매칭 (재귀적)
- `?`: 한 문자 매칭

**예시:**
```
https://example.com/auth/callback      # 정확히 이 URL만
https://example.com/auth/*             # /auth/callback, /auth/verify 등
https://example.com/**                 # 모든 하위 경로
https://*.example.com/**               # 모든 서브도메인
```

**보안 고려사항:**
- 너무 광범위한 패턴은 피하세요 (예: `https://**`)
- 프로덕션에서는 정확한 URL만 허용
- 개발 환경과 프로덕션 URL을 모두 추가
</DevTip>

3. **Save** 버튼을 클릭합니다

<Checkpoint>
- [ ] Site URL 설정 완료
- [ ] Redirect URLs 설정 완료
- [ ] 개발 및 프로덕션 URL 모두 추가 완료
</Checkpoint>

</Step>

<Step number={5} title="Next.js 앱에 인증 구현하기">

Supabase Auth를 Next.js App Router 앱에 통합합니다.

### Supabase SSR 패키지 설치

<CopyBlock language="bash">
{`npm install @supabase/ssr @supabase/supabase-js`}
</CopyBlock>

### Supabase 클라이언트 생성

`lib/supabase/client.ts` 파일을 생성합니다:

<CopyBlock language="typescript">
{`import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}`}
</CopyBlock>

`lib/supabase/server.ts` 파일을 생성합니다:

<CopyBlock language="typescript">
{`import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // Server Component에서는 set 불가
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch (error) {
            // Server Component에서는 remove 불가
          }
        },
      },
    }
  )
}`}
</CopyBlock>

### 환경 변수 설정

`.env.local` 파일에 Supabase 설정을 추가합니다:

<CopyBlock language="bash">
{`NEXT_PUBLIC_SUPABASE_URL=https://your-project-ref.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key`}
</CopyBlock>

### 회원가입 폼 만들기

`app/auth/signup/page.tsx`:

<CopyBlock language="tsx">
{`'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export default function SignUpPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState('')
  const router = useRouter()
  const supabase = createClient()

  async function handleSignUp(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)
    setMessage('')

    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: \`\${location.origin}/auth/callback\`,
      },
    })

    if (error) {
      setMessage(error.message)
    } else {
      setMessage('확인 이메일을 확인해주세요!')
    }
    setLoading(false)
  }

  return (
    <div className="max-w-md mx-auto mt-8 p-6 border rounded-lg">
      <h1 className="text-2xl font-bold mb-4">회원가입</h1>
      <form onSubmit={handleSignUp} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium mb-1">
            이메일
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="w-full px-3 py-2 border rounded"
          />
        </div>
        <div>
          <label htmlFor="password" className="block text-sm font-medium mb-1">
            비밀번호
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            minLength={6}
            className="w-full px-3 py-2 border rounded"
          />
        </div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? '처리 중...' : '가입하기'}
        </button>
      </form>
      {message && (
        <p className="mt-4 text-sm text-center text-green-600">{message}</p>
      )}
    </div>
  )
}`}
</CopyBlock>

### 로그인 폼 만들기

`app/auth/login/page.tsx`:

<CopyBlock language="tsx">
{`'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const router = useRouter()
  const supabase = createClient()

  async function handleLogin(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)
    setError('')

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      setError(error.message)
      setLoading(false)
    } else {
      router.push('/dashboard')
      router.refresh()
    }
  }

  async function handleGoogleLogin() {
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: \`\${location.origin}/auth/callback\`,
      },
    })

    if (error) {
      setError(error.message)
    }
  }

  async function handleGitHubLogin() {
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'github',
      options: {
        redirectTo: \`\${location.origin}/auth/callback\`,
      },
    })

    if (error) {
      setError(error.message)
    }
  }

  return (
    <div className="max-w-md mx-auto mt-8 p-6 border rounded-lg">
      <h1 className="text-2xl font-bold mb-4">로그인</h1>

      {/* 이메일/비밀번호 로그인 */}
      <form onSubmit={handleLogin} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium mb-1">
            이메일
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="w-full px-3 py-2 border rounded"
          />
        </div>
        <div>
          <label htmlFor="password" className="block text-sm font-medium mb-1">
            비밀번호
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            className="w-full px-3 py-2 border rounded"
          />
        </div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700"
        >
          {loading ? '로그인 중...' : '로그인'}
        </button>
      </form>

      {/* 소셜 로그인 */}
      <div className="mt-6 space-y-2">
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t"></div>
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">또는</span>
          </div>
        </div>

        <button
          onClick={handleGoogleLogin}
          className="w-full flex items-center justify-center gap-2 border py-2 rounded hover:bg-gray-50"
        >
          <svg className="w-5 h-5" viewBox="0 0 24 24">
            {/* Google 아이콘 SVG */}
          </svg>
          Google로 로그인
        </button>

        <button
          onClick={handleGitHubLogin}
          className="w-full flex items-center justify-center gap-2 border py-2 rounded hover:bg-gray-50"
        >
          <svg className="w-5 h-5" viewBox="0 0 24 24">
            {/* GitHub 아이콘 SVG */}
          </svg>
          GitHub으로 로그인
        </button>
      </div>

      {error && (
        <p className="mt-4 text-sm text-center text-red-600">{error}</p>
      )}
    </div>
  )
}`}
</CopyBlock>

### Auth Callback Route 만들기

`app/auth/callback/route.ts`:

<CopyBlock language="typescript">
{`import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      const forwardedHost = request.headers.get('x-forwarded-host')
      const isLocalEnv = process.env.NODE_ENV === 'development'
      if (isLocalEnv) {
        return NextResponse.redirect(\`\${origin}\${next}\`)
      } else if (forwardedHost) {
        return NextResponse.redirect(\`https://\${forwardedHost}\${next}\`)
      } else {
        return NextResponse.redirect(\`\${origin}\${next}\`)
      }
    }
  }

  // 오류 발생 시 에러 페이지로 리디렉션
  return NextResponse.redirect(\`\${origin}/auth/auth-code-error\`)
}`}
</CopyBlock>

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step5-nextjs-auth-ko.png"
  alt="Next.js 인증 구현"
  caption="Next.js에서 Supabase Auth를 사용한 로그인 페이지"
/>

<DevTip title="Next.js App Router 인증 패턴">
**클라이언트 컴포넌트 (Client Component):**
- 브라우저에서 실행 (`'use client'`)
- `createClient()` from `@/lib/supabase/client` 사용
- 폼 제출, 버튼 클릭 등 인터랙티브한 작업

**서버 컴포넌트 (Server Component):**
- 서버에서 실행 (기본값)
- `createClient()` from `@/lib/supabase/server` 사용
- 초기 사용자 정보 조회, 보호된 페이지 렌더링

**미들웨어 (Middleware):**
- 모든 요청에서 실행
- 인증 상태 확인 및 리디렉션
- `middleware.ts` 파일에서 설정
</DevTip>

<Checkpoint>
- [ ] Supabase SSR 패키지 설치 완료
- [ ] 클라이언트/서버 헬퍼 생성 완료
- [ ] 환경 변수 설정 완료
- [ ] 회원가입 폼 구현 완료
- [ ] 로그인 폼 구현 완료 (이메일 + OAuth)
- [ ] Auth callback route 생성 완료
</Checkpoint>

</Step>

<Step number={6} title="보호된 라우트 및 RLS 통합하기">

인증이 필요한 페이지를 보호하고 RLS와 통합합니다.

### 미들웨어로 인증 확인

`middleware.ts` 파일을 생성합니다:

<CopyBlock language="typescript">
{`import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  const {
    data: { user },
  } = await supabase.auth.getUser()

  // 보호된 라우트 체크
  if (request.nextUrl.pathname.startsWith('/dashboard') && !user) {
    return NextResponse.redirect(new URL('/auth/login', request.url))
  }

  // 인증된 사용자가 로그인 페이지 접근 시 대시보드로 리디렉션
  if (request.nextUrl.pathname.startsWith('/auth/login') && user) {
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }

  return response
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}`}
</CopyBlock>

### 보호된 페이지 만들기

`app/dashboard/page.tsx`:

<CopyBlock language="tsx">
{`import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function DashboardPage() {
  const supabase = await createClient()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user) {
    redirect('/auth/login')
  }

  return (
    <div className="max-w-4xl mx-auto mt-8 p-6">
      <h1 className="text-3xl font-bold mb-4">대시보드</h1>
      <div className="bg-white border rounded-lg p-6">
        <h2 className="text-xl font-semibold mb-2">환영합니다!</h2>
        <p className="text-gray-600 mb-4">이메일: {user.email}</p>
        <p className="text-sm text-gray-500">사용자 ID: {user.id}</p>
      </div>
    </div>
  )
}`}
</CopyBlock>

### RLS 정책과 인증 연동

이전에 생성한 `posts` 테이블의 RLS 정책이 자동으로 작동합니다:

<CopyBlock language="javascript">
{`'use client'

import { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'

export default function MyPostsPage() {
  const [posts, setPosts] = useState([])
  const supabase = createClient()

  useEffect(() => {
    fetchMyPosts()
  }, [])

  async function fetchMyPosts() {
    // auth.uid()가 자동으로 현재 로그인한 사용자의 ID를 반환
    // RLS 정책에 의해 자신의 포스트만 조회됨
    const { data, error } = await supabase
      .from('posts')
      .select('*')
      .order('created_at', { ascending: false })

    if (error) {
      console.error('Error:', error)
    } else {
      setPosts(data)
    }
  }

  async function createPost(title: string, content: string) {
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return

    const { data, error } = await supabase
      .from('posts')
      .insert({
        title,
        content,
        author_id: user.id, // 현재 사용자 ID
        published: false,
      })
      .select()

    if (error) {
      console.error('Error:', error)
    } else {
      setPosts([...posts, ...data])
    }
  }

  return (
    <div>
      <h1>내 포스트</h1>
      {/* 포스트 목록 렌더링 */}
    </div>
  )
}`}
</CopyBlock>

### 로그아웃 구현

<CopyBlock language="tsx">
{`'use client'

import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export function LogoutButton() {
  const router = useRouter()
  const supabase = createClient()

  async function handleLogout() {
    await supabase.auth.signOut()
    router.push('/')
    router.refresh()
  }

  return (
    <button
      onClick={handleLogout}
      className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
    >
      로그아웃
    </button>
  )
}`}
</CopyBlock>

<Screenshot
  src="https://res.cloudinary.com/demo/image/upload/v1234567890/guides/supabase-auth-setup/step6-protected-routes-ko.png"
  alt="보호된 라우트"
  caption="인증된 사용자만 접근할 수 있는 대시보드 페이지"
/>

<DevTip title="RLS와 인증 통합 패턴">
**자동 사용자 ID 전달:**
- Supabase 클라이언트가 자동으로 JWT를 전송
- `auth.uid()` 함수가 현재 사용자 ID 반환
- 별도의 사용자 ID 전달 불필요

**일반적인 RLS 정책 예시:**

**1. 자신의 프로필만 수정:**
```sql
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid() = id);
```

**2. 팀 멤버만 접근:**
```sql
CREATE POLICY "Team members can view team data"
ON team_data FOR SELECT
USING (
  auth.uid() IN (
    SELECT user_id FROM team_members
    WHERE team_id = team_data.team_id
  )
);
```

**3. 관리자 전용:**
```sql
CREATE POLICY "Only admins can delete"
ON posts FOR DELETE
USING (
  auth.jwt() ->> 'role' = 'admin'
);
```

**사용자 메타데이터 활용:**
회원가입 시 사용자 메타데이터를 추가하여 RLS에서 활용:
```typescript
await supabase.auth.signUp({
  email,
  password,
  options: {
    data: {
      role: 'user',
      organization_id: 'org-123',
    },
  },
})
```

RLS 정책에서 접근:
```sql
auth.jwt() ->> 'role' = 'admin'
auth.jwt() ->> 'organization_id' = organization_id
```
</DevTip>

<Checkpoint>
- [ ] 미들웨어 설정 완료
- [ ] 보호된 페이지 생성 완료
- [ ] RLS와 인증 통합 확인
- [ ] 로그아웃 기능 구현 완료
</Checkpoint>

</Step>

## 다음 단계

인증 시스템 구축을 완료했습니다! 이제 다음 기능을 추가해보세요.

### 추천 가이드

1. **[Supabase 스토리지 설정 가이드](../supabase-storage-setup)**
   - 프로필 이미지 업로드
   - 파일 저장 및 관리
   - 예상 소요 시간: 15분

## 문제 해결

### OAuth 로그인이 작동하지 않아요

**확인 사항:**
1. OAuth 앱의 Redirect URI가 정확한지 확인
   - `https://your-project-ref.supabase.co/auth/v1/callback`
2. Client ID와 Client Secret이 정확한지 확인
3. Supabase의 Redirect URLs에 앱 URL 추가했는지 확인
4. 브라우저 쿠키가 활성화되어 있는지 확인

### 이메일 확인 메일이 오지 않아요

**해결 방법:**
1. 스팸 폴더 확인
2. Authentication > Settings에서 "Confirm email" 옵션 확인
3. 개발 중에는 일시적으로 "Confirm email" 비활성화 가능
4. Email Templates에서 이메일 템플릿 확인

### RLS 정책 때문에 데이터를 생성/수정할 수 없어요

**확인 사항:**
1. 로그인 상태 확인
2. RLS 정책의 `WITH CHECK` 조건 확인
3. `author_id`가 현재 사용자 ID와 일치하는지 확인

**디버깅 팁:**
<CopyBlock language="javascript">
{`// 현재 사용자 ID 확인
const { data: { user } } = await supabase.auth.getUser()
console.log('Current user ID:', user?.id)

// 데이터 삽입 시 사용자 ID 확인
const { data, error } = await supabase
  .from('posts')
  .insert({
    title: 'Test',
    author_id: user.id,  // 이 값이 올바른지 확인
  })

console.log('Error:', error)  // RLS 오류 메시지 확인`}
</CopyBlock>

## 유용한 리소스

- [Supabase Auth 공식 문서](https://supabase.com/docs/guides/auth)
- [Next.js with Supabase 가이드](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Supabase Auth Helpers](https://supabase.com/docs/guides/auth/auth-helpers)
- [Row Level Security 가이드](https://supabase.com/docs/guides/auth/row-level-security)
- [OAuth Provider 설정 가이드](https://supabase.com/docs/guides/auth/social-login)
